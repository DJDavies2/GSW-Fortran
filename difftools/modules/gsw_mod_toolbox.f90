module gsw_mod_toolbox

  use gsw_mod_kinds

  implicit none

  public
  
!!$  :: gsw_ct_from_pt
!!$  public :: gsw_sa_from_sp
!!$  public :: gsw_t_from_ct
!!$  public :: gsw_pt_from_t
!!$  public :: gsw_saar
!!$  public :: gsw_add_barrier
!!$  public :: gsw_add_mean  
!!$  public :: gsw_util_indx
!!$  public :: gsw_entropy_part
!!$  public :: gsw_gibbs  
!!$  public :: gsw_sa_from_sp_baltic
!!$  public :: gsw_util_xinterp1
!!$  public :: gsw_pt_from_ct   
!!$  public :: gsw_gibbs_pt0_pt0

contains

  !==========================================================================
  pure subroutine gsw_add_barrier (input_data, long, lat, long_grid, &
       lat_grid, dlong_grid, dlat_grid, output_data)
    !==========================================================================
    !
    !  Adds a barrier through Central America (Panama) and then averages
    !  over the appropriate side of the barrier
    ! 
    !  data_in      : data                                            [unitless]
    !  long         : Long of data in decimal degs east               [ 0 ... +360 ]
    !  lat          : Lat of data in decimal degs north               [-90 ... +90 ]
    !  longs_grid   : Long of regular grid in decimal degs east       [ 0 ... +360 ]
    !  lats_grid    : Lat of regular grid in decimal degs north       [-90 ... +90 ]
    !  dlongs_grid  : Long difference of regular grid in decimal degs [ deg long ]
    !  dlats_grid   : Lat difference of regular grid in decimal degs  [ deg lat ]
    !
    ! output_data   : average of data depending on which side of the 
    !                 Panama canal it is on                           [unitless]
    !--------------------------------------------------------------------------

    use gsw_mod_toolbox, only : gsw_util_indx

    use gsw_mod_saar_data

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in) :: long, lat, long_grid, lat_grid, dlong_grid
    real (r8), intent(in) :: dlat_grid
    real (r8), intent(in), dimension(4) :: input_data
    real (r8), intent(out), dimension(4) :: output_data

    integer, dimension(4) :: above_line
    integer :: k, nmean, above_line0, kk
    real (r8) :: r, lats_line, data_mean

    k = gsw_util_indx(longs_pan,long)                !   the long/lat point
    r = (long-longs_pan(k))/(longs_pan(k+1)-longs_pan(k))
    lats_line = lats_pan(k) + r*(lats_pan(k+1)-lats_pan(k))

    if (lats_line.le.lat) then
       above_line0 = 1
    else
       above_line0 = 0
    end if

    k = gsw_util_indx(longs_pan,long_grid)       ! the 1 and 4 long/lat pts
    r = (long_grid-longs_pan(k))/(longs_pan(k+1)-longs_pan(k))
    lats_line = lats_pan(k) + r*(lats_pan(k+1)-lats_pan(k))

    if (lats_line.le.lat_grid) then
       above_line(1) = 1
    else
       above_line(1) = 0
    end if

    if (lats_line.le.lat_grid+dlat_grid) then
       above_line(4) = 1
    else
       above_line(4) = 0
    end if

    k = gsw_util_indx(longs_pan,long_grid+dlong_grid)    ! the 2 & 3 points 
    r = (long_grid+dlong_grid-longs_pan(k))/(longs_pan(k+1)-longs_pan(k))
    lats_line = lats_pan(k) + r*(lats_pan(k+1)-lats_pan(k))

    if (lats_line.le.lat_grid) then
       above_line(2) = 1
    else
       above_line(2) = 0
    end if

    if (lats_line.le.lat_grid+dlat_grid) then
       above_line(3) = 1
    else
       above_line(3) = 0
    end if

    nmean = 0 
    data_mean = 0.0_r8

    do kk = 1,4
       if ((abs(input_data(kk)).le.100._r8).and.above_line0.eq.above_line(kk)) then
          nmean = nmean + 1
          data_mean = data_mean + input_data(kk)
       end if
    end do

    if (nmean .eq. 0)then
       data_mean = 0.0_r8    !errorreturn
    else
       data_mean = data_mean/nmean
    endif

    do kk = 1,4
       if ((abs(input_data(kk)).ge.1e10_r8).or.above_line0.ne.above_line(kk)) then
          output_data(kk) = data_mean
       else
          output_data(kk) = input_data(kk)
       end if
    end do

    return
  end subroutine gsw_add_barrier

  !--------------------------------------------------------------------------
  !==========================================================================
  pure subroutine gsw_add_mean (data_in, data_out)
    !==========================================================================
    !
    ! Replaces NaN's with non-nan mean of the 4 adjacent neighbours
    !
    ! data_in   : data set of the 4 adjacent neighbours   
    !
    ! data_out : non-nan mean of the 4 adjacent neighbours     [unitless]
    !--------------------------------------------------------------------------

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in), dimension(4) :: data_in
    real (r8), intent(out), dimension(4) :: data_out

    integer :: k, nmean

    real (r8) :: data_mean

    nmean = 0
    data_mean = 0.0_r8

    do k = 1,4
       if (abs(data_in(k)).le.100.0_r8) then
          nmean = nmean + 1
          data_mean = data_mean + data_in(k)
       end if
    end do

    if(nmean.eq.0)then
       data_mean = 0.0_r8    !error return
    else
       data_mean = data_mean/nmean
    endif

    do k = 1,4
       if(abs(data_in(k)).le.100.0_r8) then
          data_out(k) = data_in(k)
       else
          data_out(k) = data_mean
       end if
    end do

    return
  end subroutine gsw_add_mean

  !--------------------------------------------------------------------------
  !==========================================================================
  elemental function gsw_ct_from_pt (sa, pt) 
    !==========================================================================
    !
    ! Calculates Conservative Temperature from potential temperature of seawater  
    !
    ! sa      : Absolute Salinity                              [g/kg]
    ! pt      : potential temperature with                     [deg C]
    !           reference pressure of 0 dbar
    !
    ! gsw_ct_from_pt : Conservative Temperature                [deg C]
    !--------------------------------------------------------------------------

    use gsw_mod_teos10_constants, only : gsw_cp0, gsw_sfac

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in) :: sa, pt 

    real (r8) :: gsw_ct_from_pt

    real (r8) :: pot_enthalpy, x2, x, y

    x2 = gsw_sfac*sa
    x = sqrt(x2)
    y = pt*0.025_r8        ! normalize for F03 and F08

    pot_enthalpy =  61.01362420681071_r8 + y*(168776.46138048015_r8 + &
         y*(-2735.2785605119625_r8 + y*(2574.2164453821433_r8 + &
         y*(-1536.6644434977543_r8 + y*(545.7340497931629_r8 + &
         (-50.91091728474331_r8 - 18.30489878927802_r8*y)*y))))) + &
         x2*(268.5520265845071_r8 + y*(-12019.028203559312_r8 + &
         y*(3734.858026725145_r8 + y*(-2046.7671145057618_r8 + &
         y*(465.28655623826234_r8 + (-0.6370820302376359_r8 - &
         10.650848542359153_r8*y)*y)))) + &
         x*(937.2099110620707_r8 + y*(588.1802812170108_r8 + &
         y*(248.39476522971285_r8 + (-3.871557904936333_r8 - &
         2.6268019854268356_r8*y)*y)) + &
         x*(-1687.914374187449_r8 + x*(246.9598888781377_r8 + &
         x*(123.59576582457964_r8 - 48.5891069025409_r8*x)) + &
         y*(936.3206544460336_r8 + &
         y*(-942.7827304544439_r8 + y*(369.4389437509002_r8 + &
         (-33.83664947895248_r8 - 9.987880382780322_r8*y)*y))))))

    gsw_ct_from_pt = pot_enthalpy/gsw_cp0

    return
  end function gsw_ct_from_pt

  !--------------------------------------------------------------------------
  !==========================================================================
  elemental function gsw_entropy_part (sa, t, p)
    !==========================================================================
    !
    ! entropy minus the terms that are a function of only SA
    !
    ! sa     : Absolute Salinity                               [g/kg]
    ! t      : in-situ temperature                             [deg C]
    ! p      : sea pressure                                    [dbar]
    ! 
    ! gsw_entropy_part : entropy part
    !--------------------------------------------------------------------------

    use gsw_mod_teos10_constants, only : gsw_sfac

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in) :: sa, t, p

    real (r8) :: gsw_entropy_part

    real (r8) :: x2, x, y, z, g03, g08

    x2 = gsw_sfac*sa
    x = sqrt(x2)
    y = t*0.025_r8
    z = p*1e-4_r8

    g03 = z*(-270.983805184062_r8 + &
         z*(776.153611613101_r8 + z*(-196.51255088122_r8 + (28.9796526294175_r8 - 2.13290083518327_r8*z)*z))) + &
         y*(-24715.571866078_r8 + z*(2910.0729080936_r8 + &
         z*(-1513.116771538718_r8 + z*(546.959324647056_r8 + z*(-111.1208127634436_r8 + 8.68841343834394_r8*z)))) + &
         y*(2210.2236124548363_r8 + z*(-2017.52334943521_r8 + &
         z*(1498.081172457456_r8 + z*(-718.6359919632359_r8 + (146.4037555781616_r8 - 4.9892131862671505_r8*z)*z))) + &
         y*(-592.743745734632_r8 + z*(1591.873781627888_r8 + &
         z*(-1207.261522487504_r8 + (608.785486935364_r8 - 105.4993508931208_r8*z)*z)) + &
         y*(290.12956292128547_r8 + z*(-973.091553087975_r8 + &
         z*(602.603274510125_r8 + z*(-276.361526170076_r8 + 32.40953340386105_r8*z))) + &
         y*(-113.90630790850321_r8 + y*(21.35571525415769_r8 - 67.41756835751434_r8*z) + &
         z*(381.06836198507096_r8 + z*(-133.7383902842754_r8 + 49.023632509086724_r8*z)))))))

    g08 = x2*(z*(729.116529735046_r8 + &
         z*(-343.956902961561_r8 + z*(124.687671116248_r8 + z*(-31.656964386073_r8 + 7.04658803315449_r8*z)))) + &
         x*( x*(y*(-137.1145018408982_r8 + y*(148.10030845687618_r8 + y*(-68.5590309679152_r8 + 12.4848504784754_r8*y))) - &
         22.6683558512829_r8*z) + z*(-175.292041186547_r8 + (83.1923927801819_r8 - 29.483064349429_r8*z)*z) + &
         y*(-86.1329351956084_r8 + z*(766.116132004952_r8 + z*(-108.3834525034224_r8 + 51.2796974779828_r8*z)) + &
         y*(-30.0682112585625_r8 - 1380.9597954037708_r8*z + y*(3.50240264723578_r8 + 938.26075044542_r8*z)))) + &
         y*(1760.062705994408_r8 + y*(-675.802947790203_r8 + &
         y*(365.7041791005036_r8 + y*(-108.30162043765552_r8 + 12.78101825083098_r8*y) + &
         z*(-1190.914967948748_r8 + (298.904564555024_r8 - 145.9491676006352_r8*z)*z)) + &
         z*(2082.7344423998043_r8 + z*(-614.668925894709_r8 + (340.685093521782_r8 - 33.3848202979239_r8*z)*z))) + &
         z*(-1721.528607567954_r8 + z*(674.819060538734_r8 + &
         z*(-356.629112415276_r8 + (88.4080716616_r8 - 15.84003094423364_r8*z)*z)))))

    gsw_entropy_part = -(g03 + g08)*0.025_r8

    return
  end function gsw_entropy_part

  !--------------------------------------------------------------------------
  !==========================================================================
  elemental function gsw_gibbs (ns, nt, np, sa, t, p)
    !==========================================================================
    !
    ! seawater specific Gibbs free energy and derivatives up to order 2
    !
    ! ns     : order of s derivative
    ! nt     : order of t derivative
    ! np     : order of p derivative
    ! sa     : Absolute Salinity                               [g/kg]
    ! t      : temperature                                     [deg C]
    ! p      : sea pressure                                    [dbar]
    ! 
    ! gsw_gibbs  : specific Gibbs energy or its derivative
    !--------------------------------------------------------------------------

    use gsw_mod_teos10_constants, only : gsw_sfac

    use gsw_mod_error_functions, only : gsw_error_code

    use gsw_mod_kinds

    implicit none

    integer, intent(in) :: ns, nt, np
    real (r8), intent(in) :: sa, t, p

    real (r8) :: gsw_gibbs

    real (r8) :: x2, x, y, z, g03, g08

    character (*), parameter :: func_name = "gsw_gibbs"

    x2 = gsw_sfac*sa
    x = sqrt(x2)
    y = t*0.025_r8
    z = p*1e-4_r8

    if (ns.eq.0 .and. nt.eq.0 .and. np.eq.0) then

       g03 = 101.342743139674_r8 + z*(100015.695367145_r8 + &
            z*(-2544.5765420363_r8 + z*(284.517778446287_r8 + &
            z*(-33.3146754253611_r8 + (4.20263108803084_r8 - 0.546428511471039_r8*z)*z)))) + &
            y*(5.90578347909402_r8 + z*(-270.983805184062_r8 + &
            z*(776.153611613101_r8 + z*(-196.51255088122_r8 + (28.9796526294175_r8 - 2.13290083518327_r8*z)*z))) + &
            y*(-12357.785933039_r8 + z*(1455.0364540468_r8 + &
            z*(-756.558385769359_r8 + z*(273.479662323528_r8 + z*(-55.5604063817218_r8 + 4.34420671917197_r8*z)))) + &
            y*(736.741204151612_r8 + z*(-672.50778314507_r8 + &
            z*(499.360390819152_r8 + z*(-239.545330654412_r8 + (48.8012518593872_r8 - 1.66307106208905_r8*z)*z))) + &
            y*(-148.185936433658_r8 + z*(397.968445406972_r8 + &
            z*(-301.815380621876_r8 + (152.196371733841_r8 - 26.3748377232802_r8*z)*z)) + &
            y*(58.0259125842571_r8 + z*(-194.618310617595_r8 + &
            z*(120.520654902025_r8 + z*(-55.2723052340152_r8 + 6.48190668077221_r8*z))) + &
            y*(-18.9843846514172_r8 + y*(3.05081646487967_r8 - 9.63108119393062_r8*z) + &
            z*(63.5113936641785_r8 + z*(-22.2897317140459_r8 + 8.17060541818112_r8*z))))))))

       g08 = x2*(1416.27648484197_r8 + z*(-3310.49154044839_r8 + &
            z*(384.794152978599_r8 + z*(-96.5324320107458_r8 + (15.8408172766824_r8 - 2.62480156590992_r8*z)*z))) + &
            x*(-2432.14662381794_r8 + x*(2025.80115603697_r8 + &
            y*(543.835333000098_r8 + y*(-68.5572509204491_r8 + &
            y*(49.3667694856254_r8 + y*(-17.1397577419788_r8 + 2.49697009569508_r8*y))) - 22.6683558512829_r8*z) + &
            x*(-1091.66841042967_r8 - 196.028306689776_r8*y + &
            x*(374.60123787784_r8 - 48.5891069025409_r8*x + 36.7571622995805_r8*y) + 36.0284195611086_r8*z) + &
            z*(-54.7919133532887_r8 + (-4.08193978912261_r8 - 30.1755111971161_r8*z)*z)) + &
            z*(199.459603073901_r8 + z*(-52.2940909281335_r8 + (68.0444942726459_r8 - 3.41251932441282_r8*z)*z)) + &
            y*(-493.407510141682_r8 + z*(-175.292041186547_r8 + (83.1923927801819_r8 - 29.483064349429_r8*z)*z) + &
            y*(-43.0664675978042_r8 + z*(383.058066002476_r8 + z*(-54.1917262517112_r8 + 25.6398487389914_r8*z)) + &
            y*(-10.0227370861875_r8 - 460.319931801257_r8*z + y*(0.875600661808945_r8 + 234.565187611355_r8*z))))) + &
            y*(168.072408311545_r8 + z*(729.116529735046_r8 + &
            z*(-343.956902961561_r8 + z*(124.687671116248_r8 + z*(-31.656964386073_r8 + 7.04658803315449_r8*z)))) + &
            y*(880.031352997204_r8 + y*(-225.267649263401_r8 + &
            y*(91.4260447751259_r8 + y*(-21.6603240875311_r8 + 2.13016970847183_r8*y) + &
            z*(-297.728741987187_r8 + (74.726141138756_r8 - 36.4872919001588_r8*z)*z)) + &
            z*(694.244814133268_r8 + z*(-204.889641964903_r8 + (113.561697840594_r8 - 11.1282734326413_r8*z)*z))) + &
            z*(-860.764303783977_r8 + z*(337.409530269367_r8 + &
            z*(-178.314556207638_r8 + (44.2040358308_r8 - 7.92001547211682_r8*z)*z))))))

       if (sa.gt.0.0_r8) &
            g08 = g08 + x2*(5812.81456626732_r8 + 851.226734946706_r8*y)*log(x)

       gsw_gibbs = g03 + g08

    elseif (ns.eq.1 .and. nt.eq.0 .and. np.eq.0) then

       g08 = 8645.36753595126_r8 + z*(-6620.98308089678_r8 + &
            z*(769.588305957198_r8 + z*(-193.0648640214916_r8 + (31.6816345533648_r8 - 5.24960313181984_r8*z)*z))) + &
            x*(-7296.43987145382_r8 + x*(8103.20462414788_r8 + &
            y*(2175.341332000392_r8 + y*(-274.2290036817964_r8 + &
            y*(197.4670779425016_r8 + y*(-68.5590309679152_r8 + 9.98788038278032_r8*y))) - 90.6734234051316_r8*z) + &
            x*(-5458.34205214835_r8 - 980.14153344888_r8*y + &
            x*(2247.60742726704_r8 - 340.1237483177863_r8*x + 220.542973797483_r8*y) + 180.142097805543_r8*z) + &
            z*(-219.1676534131548_r8 + (-16.32775915649044_r8 - 120.7020447884644_r8*z)*z)) + &
            z*(598.378809221703_r8 + z*(-156.8822727844005_r8 + (204.1334828179377_r8 - 10.23755797323846_r8*z)*z)) + &
            y*(-1480.222530425046_r8 + z*(-525.876123559641_r8 + (249.57717834054571_r8 - 88.449193048287_r8*z)*z) + &
            y*(-129.1994027934126_r8 + z*(1149.174198007428_r8 + z*(-162.5751787551336_r8 + 76.9195462169742_r8*z)) + &
            y*(-30.0682112585625_r8 - 1380.9597954037708_r8*z + y*(2.626801985426835_r8 + 703.695562834065_r8*z))))) + &
            y*(1187.3715515697959_r8 + z*(1458.233059470092_r8 + &
            z*(-687.913805923122_r8 + z*(249.375342232496_r8 + z*(-63.313928772146_r8 + 14.09317606630898_r8*z)))) + &
            y*(1760.062705994408_r8 + y*(-450.535298526802_r8 + &
            y*(182.8520895502518_r8 + y*(-43.3206481750622_r8 + 4.26033941694366_r8*y) + &
            z*(-595.457483974374_r8 + (149.452282277512_r8 - 72.9745838003176_r8*z)*z)) + &
            z*(1388.489628266536_r8 + z*(-409.779283929806_r8 + (227.123395681188_r8 - 22.2565468652826_r8*z)*z))) + &
            z*(-1721.528607567954_r8 + z*(674.819060538734_r8 + &
            z*(-356.629112415276_r8 + (88.4080716616_r8 - 15.84003094423364_r8*z)*z)))))

       if (sa.gt.0_r8) then
          g08 = g08 + (11625.62913253464_r8 + 1702.453469893412_r8*y)*log(x)
       else
          g08 = 0.0_r8
       endif

       gsw_gibbs = 0.5*gsw_sfac*g08

    elseif (ns.eq.0 .and. nt.eq.1 .and. np.eq.0) then

       g03 = 5.90578347909402_r8 + z*(-270.983805184062_r8 + &
            z*(776.153611613101_r8 + z*(-196.51255088122_r8 + (28.9796526294175_r8 - 2.13290083518327_r8*z)*z))) + &
            y*(-24715.571866078_r8 + z*(2910.0729080936_r8 + &
            z*(-1513.116771538718_r8 + z*(546.959324647056_r8 + z*(-111.1208127634436_r8 + 8.68841343834394_r8*z)))) + &
            y*(2210.2236124548363_r8 + z*(-2017.52334943521_r8 + &
            z*(1498.081172457456_r8 + z*(-718.6359919632359_r8 + (146.4037555781616_r8 - 4.9892131862671505_r8*z)*z))) + &
            y*(-592.743745734632_r8 + z*(1591.873781627888_r8 + &
            z*(-1207.261522487504_r8 + (608.785486935364_r8 - 105.4993508931208_r8*z)*z)) + &
            y*(290.12956292128547_r8 + z*(-973.091553087975_r8 + &
            z*(602.603274510125_r8 + z*(-276.361526170076_r8 + 32.40953340386105_r8*z))) + &
            y*(-113.90630790850321_r8 + y*(21.35571525415769_r8 - 67.41756835751434_r8*z) + &
            z*(381.06836198507096_r8 + z*(-133.7383902842754_r8 + 49.023632509086724_r8*z)))))))

       g08 = x2*(168.072408311545_r8 + z*(729.116529735046_r8 + &
            z*(-343.956902961561_r8 + z*(124.687671116248_r8 + z*(-31.656964386073_r8 + 7.04658803315449_r8*z)))) + &
            x*(-493.407510141682_r8 + x*(543.835333000098_r8 + x*(-196.028306689776_r8 + 36.7571622995805_r8*x) + &
            y*(-137.1145018408982_r8 + y*(148.10030845687618_r8 + y*(-68.5590309679152_r8 + 12.4848504784754_r8*y))) - &
            22.6683558512829_r8*z) + z*(-175.292041186547_r8 + (83.1923927801819_r8 - 29.483064349429_r8*z)*z) + &
            y*(-86.1329351956084_r8 + z*(766.116132004952_r8 + z*(-108.3834525034224_r8 + 51.2796974779828_r8*z)) + &
            y*(-30.0682112585625_r8 - 1380.9597954037708_r8*z + y*(3.50240264723578_r8 + 938.26075044542_r8*z)))) + &
            y*(1760.062705994408_r8 + y*(-675.802947790203_r8 + &
            y*(365.7041791005036_r8 + y*(-108.30162043765552_r8 + 12.78101825083098_r8*y) + &
            z*(-1190.914967948748_r8 + (298.904564555024_r8 - 145.9491676006352_r8*z)*z)) + &
            z*(2082.7344423998043_r8 + z*(-614.668925894709_r8 + (340.685093521782_r8 - 33.3848202979239_r8*z)*z))) + &
            z*(-1721.528607567954_r8 + z*(674.819060538734_r8 + &
            z*(-356.629112415276_r8 + (88.4080716616_r8 - 15.84003094423364_r8*z)*z)))))

       if (sa.gt.0_r8) g08 = g08 + 851.226734946706_r8*x2*log(x)

       gsw_gibbs = (g03 + g08)*0.025_r8

    elseif (ns.eq.0 .and. nt.eq.0 .and. np.eq.1) then

       g03 = 100015.695367145_r8 + z*(-5089.1530840726_r8 + &
            z*(853.5533353388611_r8 + z*(-133.2587017014444_r8 + (21.0131554401542_r8 - 3.278571068826234_r8*z)*z))) + &
            y*(-270.983805184062_r8 + z*(1552.307223226202_r8 + &
            z*(-589.53765264366_r8 + (115.91861051767_r8 - 10.664504175916349_r8*z)*z)) + &
            y*(1455.0364540468_r8 + z*(-1513.116771538718_r8 + &
            z*(820.438986970584_r8 + z*(-222.2416255268872_r8 + 21.72103359585985_r8*z))) + &
            y*(-672.50778314507_r8 + z*(998.720781638304_r8 + &
            z*(-718.6359919632359_r8 + (195.2050074375488_r8 - 8.31535531044525_r8*z)*z)) + &
            y*(397.968445406972_r8 + z*(-603.630761243752_r8 + (456.589115201523_r8 - 105.4993508931208_r8*z)*z) + &
            y*(-194.618310617595_r8 + y*(63.5113936641785_r8 - 9.63108119393062_r8*y + &
            z*(-44.5794634280918_r8 + 24.511816254543362_r8*z)) + &
            z*(241.04130980405_r8 + z*(-165.8169157020456_r8 + &
            25.92762672308884_r8*z)))))))                                                           

       g08 = x2*(-3310.49154044839_r8 + z*(769.588305957198_r8 + &
            z*(-289.5972960322374_r8 + (63.3632691067296_r8 - 13.1240078295496_r8*z)*z)) + &
            x*(199.459603073901_r8 + x*(-54.7919133532887_r8 + 36.0284195611086_r8*x - 22.6683558512829_r8*y + &
            (-8.16387957824522_r8 - 90.52653359134831_r8*z)*z) + &
            z*(-104.588181856267_r8 + (204.1334828179377_r8 - 13.65007729765128_r8*z)*z) + &
            y*(-175.292041186547_r8 + (166.3847855603638_r8 - 88.449193048287_r8*z)*z + &
            y*(383.058066002476_r8 + y*(-460.319931801257_r8 + 234.565187611355_r8*y) + &
            z*(-108.3834525034224_r8 + 76.9195462169742_r8*z)))) + &
            y*(729.116529735046_r8 + z*(-687.913805923122_r8 + &
            z*(374.063013348744_r8 + z*(-126.627857544292_r8 + 35.23294016577245_r8*z))) + &
            y*(-860.764303783977_r8 + y*(694.244814133268_r8 + &
            y*(-297.728741987187_r8 + (149.452282277512_r8 - 109.46187570047641_r8*z)*z) + &
            z*(-409.779283929806_r8 + (340.685093521782_r8 - 44.5130937305652_r8*z)*z)) + &
            z*(674.819060538734_r8 + z*(-534.943668622914_r8 + (176.8161433232_r8 - 39.600077360584095_r8*z)*z)))))

       gsw_gibbs = (g03 + g08)*1e-8_r8

    elseif (ns.eq.0 .and. nt.eq.2 .and. np.eq.0) then

       g03 = -24715.571866078_r8 + z*(2910.0729080936_r8 + z* &
            (-1513.116771538718_r8 + z*(546.959324647056_r8 + z*(-111.1208127634436_r8 + 8.68841343834394_r8*z)))) + &
            y*(4420.4472249096725_r8 + z*(-4035.04669887042_r8 + &
            z*(2996.162344914912_r8 + z*(-1437.2719839264719_r8 + (292.8075111563232_r8 - 9.978426372534301_r8*z)*z))) + &
            y*(-1778.231237203896_r8 + z*(4775.621344883664_r8 + &
            z*(-3621.784567462512_r8 + (1826.356460806092_r8 - 316.49805267936244_r8*z)*z)) + &
            y*(1160.5182516851419_r8 + z*(-3892.3662123519_r8 + &
            z*(2410.4130980405_r8 + z*(-1105.446104680304_r8 + 129.6381336154442_r8*z))) + &
            y*(-569.531539542516_r8 + y*(128.13429152494615_r8 - 404.50541014508605_r8*z) + &
            z*(1905.341809925355_r8 + z*(-668.691951421377_r8 + 245.11816254543362_r8*z))))))

       g08 = x2*(1760.062705994408_r8 + x*(-86.1329351956084_r8 + &
            x*(-137.1145018408982_r8 + y*(296.20061691375236_r8 + y*(-205.67709290374563_r8 + 49.9394019139016_r8*y))) + &
            z*(766.116132004952_r8 + z*(-108.3834525034224_r8 + 51.2796974779828_r8*z)) + &
            y*(-60.136422517125_r8 - 2761.9195908075417_r8*z + y*(10.50720794170734_r8 + 2814.78225133626_r8*z))) + &
            y*(-1351.605895580406_r8 + y*(1097.1125373015109_r8 + y*(-433.20648175062206_r8 + 63.905091254154904_r8*y) + &
            z*(-3572.7449038462437_r8 + (896.713693665072_r8 - 437.84750280190565_r8*z)*z)) + &
            z*(4165.4688847996085_r8 + z*(-1229.337851789418_r8 + (681.370187043564_r8 - 66.7696405958478_r8*z)*z))) + &
            z*(-1721.528607567954_r8 + z*(674.819060538734_r8 + &
            z*(-356.629112415276_r8 + (88.4080716616_r8 - 15.84003094423364_r8*z)*z))))

       gsw_gibbs = (g03 + g08)*0.000625_r8  

    elseif (ns.eq.1 .and. nt.eq.0 .and. np.eq.1) then

       g08 = -6620.98308089678_r8 + z*(1539.176611914396_r8 + &
            z*(-579.1945920644748_r8 + (126.7265382134592_r8 - 26.2480156590992_r8*z)*z)) + &
            x*(598.378809221703_r8 + x*(-219.1676534131548_r8 + 180.142097805543_r8*x - 90.6734234051316_r8*y + &
            (-32.65551831298088_r8 - 362.10613436539325_r8*z)*z) + &
            z*(-313.764545568801_r8 + (612.4004484538132_r8 - 40.95023189295384_r8*z)*z) + &
            y*(-525.876123559641_r8 + (499.15435668109143_r8 - 265.347579144861_r8*z)*z + &
            y*(1149.174198007428_r8 + y*(-1380.9597954037708_r8 + 703.695562834065_r8*y) + &
            z*(-325.1503575102672_r8 + 230.7586386509226_r8*z)))) + &
            y*(1458.233059470092_r8 + z*(-1375.827611846244_r8 + &
            z*(748.126026697488_r8 + z*(-253.255715088584_r8 + 70.4658803315449_r8*z))) + &
            y*(-1721.528607567954_r8 + y*(1388.489628266536_r8 + &
            y*(-595.457483974374_r8 + (298.904564555024_r8 - 218.92375140095282_r8*z)*z) + &
            z*(-819.558567859612_r8 + (681.370187043564_r8 - 89.0261874611304_r8*z)*z)) + &
            z*(1349.638121077468_r8 + z*(-1069.887337245828_r8 + (353.6322866464_r8 - 79.20015472116819_r8*z)*z))))    

       gsw_gibbs = g08*gsw_sfac*0.5e-8_r8

    elseif (ns.eq.0 .and. nt.eq.1 .and. np.eq.1) then

       g03 = -270.983805184062_r8 + z*(1552.307223226202_r8 + z*(-589.53765264366_r8 + &
            (115.91861051767_r8 - 10.664504175916349_r8*z)*z)) + &
            y*(2910.0729080936_r8 + z*(-3026.233543077436_r8 + &
            z*(1640.877973941168_r8 + z*(-444.4832510537744_r8 + 43.4420671917197_r8*z))) + &
            y*(-2017.52334943521_r8 + z*(2996.162344914912_r8 + &
            z*(-2155.907975889708_r8 + (585.6150223126464_r8 - 24.946065931335752_r8*z)*z)) + &
            y*(1591.873781627888_r8 + z*(-2414.523044975008_r8 + (1826.356460806092_r8 - 421.9974035724832_r8*z)*z) + &
            y*(-973.091553087975_r8 + z*(1205.20654902025_r8 + z*(-829.084578510228_r8 + 129.6381336154442_r8*z)) + &
            y*(381.06836198507096_r8 - 67.41756835751434_r8*y + z*(-267.4767805685508_r8 + 147.07089752726017_r8*z))))))

       g08 = x2*(729.116529735046_r8 + z*(-687.913805923122_r8 + &
            z*(374.063013348744_r8 + z*(-126.627857544292_r8 + 35.23294016577245_r8*z))) + &
            x*(-175.292041186547_r8 - 22.6683558512829_r8*x + (166.3847855603638_r8 - 88.449193048287_r8*z)*z + &
            y*(766.116132004952_r8 + y*(-1380.9597954037708_r8 + 938.26075044542_r8*y) + &
            z*(-216.7669050068448_r8 + 153.8390924339484_r8*z))) + &
            y*(-1721.528607567954_r8 + y*(2082.7344423998043_r8 + &
            y*(-1190.914967948748_r8 + (597.809129110048_r8 - 437.84750280190565_r8*z)*z) + &
            z*(-1229.337851789418_r8 + (1022.055280565346_r8 - 133.5392811916956_r8*z)*z)) + &
            z*(1349.638121077468_r8 + z*(-1069.887337245828_r8 + (353.6322866464_r8 - 79.20015472116819_r8*z)*z))))

       gsw_gibbs = (g03 + g08)*2.5e-10_r8

    elseif (ns.eq.1 .and. nt.eq.1 .and. np.eq.0) then

       g08 = 1187.3715515697959_r8 + z*(1458.233059470092_r8 + &
            z*(-687.913805923122_r8 + z*(249.375342232496_r8 + z*(-63.313928772146_r8 + 14.09317606630898_r8*z)))) + &
            x*(-1480.222530425046_r8 + x*(2175.341332000392_r8 + x*(-980.14153344888_r8 + 220.542973797483_r8*x) + &
            y*(-548.4580073635929_r8 + y*(592.4012338275047_r8 + y*(-274.2361238716608_r8 + 49.9394019139016_r8*y))) - &
            90.6734234051316_r8*z) + z*(-525.876123559641_r8 + (249.57717834054571_r8 - 88.449193048287_r8*z)*z) + &
            y*(-258.3988055868252_r8 + z*(2298.348396014856_r8 + z*(-325.1503575102672_r8 + 153.8390924339484_r8*z)) + &
            y*(-90.2046337756875_r8 - 4142.8793862113125_r8*z + y*(10.50720794170734_r8 + 2814.78225133626_r8*z)))) + &
            y*(3520.125411988816_r8 + y*(-1351.605895580406_r8 + &
            y*(731.4083582010072_r8 + y*(-216.60324087531103_r8 + 25.56203650166196_r8*y) + &
            z*(-2381.829935897496_r8 + (597.809129110048_r8 - 291.8983352012704_r8*z)*z)) + &
            z*(4165.4688847996085_r8 + z*(-1229.337851789418_r8 + (681.370187043564_r8 - 66.7696405958478_r8*z)*z))) + &
            z*(-3443.057215135908_r8 + z*(1349.638121077468_r8 + &
            z*(-713.258224830552_r8 + (176.8161433232_r8 - 31.68006188846728_r8*z)*z))))

       if (sa.gt.0_r8) g08 = g08 + 1702.453469893412_r8*log(x)

       gsw_gibbs = 0.5_r8*gsw_sfac*0.025_r8*g08

    elseif (ns.eq.2 .and. nt.eq.0 .and. np.eq.0) then

       g08 = 2.0_r8*(8103.20462414788_r8 + &
            y*(2175.341332000392_r8 + y*(-274.2290036817964_r8 + &
            y*(197.4670779425016_r8 + y*(-68.5590309679152_r8 + 9.98788038278032_r8*y))) - 90.6734234051316_r8*z) + &
            1.5_r8*x*(-5458.34205214835_r8 - 980.14153344888_r8*y + &
            (4.0_r8/3.0_r8)*x*(2247.60742726704_r8 - 340.1237483177863_r8*1.25_r8*x + 220.542973797483_r8*y) + &
            180.142097805543_r8*z) + &
            z*(-219.1676534131548_r8 + (-16.32775915649044_r8 - 120.7020447884644_r8*z)*z))

       if (x.gt.0_r8) then
          g08 = g08 + (-7296.43987145382_r8 + z*(598.378809221703_r8 + &
               z*(-156.8822727844005_r8 + (204.1334828179377_r8 - 10.23755797323846_r8*z)*z)) + &
               y*(-1480.222530425046_r8 + z*(-525.876123559641_r8 + &
               (249.57717834054571_r8 - 88.449193048287_r8*z)*z) + &
               y*(-129.1994027934126_r8 + z*(1149.174198007428_r8 + &
               z*(-162.5751787551336_r8 + 76.9195462169742_r8*z)) + &
               y*(-30.0682112585625_r8 - 1380.9597954037708_r8*z + &
               y*(2.626801985426835_r8 + 703.695562834065_r8*z)))))/x + &
               (11625.62913253464_r8 + 1702.453469893412_r8*y)/x2
       else
          g08 = 0.0_r8
       end if

       gsw_gibbs = 0.25_r8*gsw_sfac*gsw_sfac*g08

    elseif (ns.eq.0 .and. nt.eq.0 .and. np.eq.2) then

       g03 = -5089.1530840726_r8 + z*(1707.1066706777221_r8 + &
            z*(-399.7761051043332_r8 + (84.0526217606168_r8 - 16.39285534413117_r8*z)*z)) + &
            y*(1552.307223226202_r8 + z*(-1179.07530528732_r8 + (347.75583155301_r8 - 42.658016703665396_r8*z)*z) + &
            y*(-1513.116771538718_r8 + z*(1640.877973941168_r8 + z*(-666.7248765806615_r8 + 86.8841343834394_r8*z)) + &
            y*(998.720781638304_r8 + z*(-1437.2719839264719_r8 + (585.6150223126464_r8 - 33.261421241781_r8*z)*z) + &
            y*(-603.630761243752_r8 + (913.178230403046_r8 - 316.49805267936244_r8*z)*z + &
            y*(241.04130980405_r8 + y*(-44.5794634280918_r8 + 49.023632509086724_r8*z) + &
            z*(-331.6338314040912_r8 + 77.78288016926652_r8*z))))))

       g08 = x2*(769.588305957198_r8 + z*(-579.1945920644748_r8 + (190.08980732018878_r8 - 52.4960313181984_r8*z)*z) + &
            x*(-104.588181856267_r8 + x*(-8.16387957824522_r8 - 181.05306718269662_r8*z) + &
            (408.2669656358754_r8 - 40.95023189295384_r8*z)*z + &
            y*(166.3847855603638_r8 - 176.898386096574_r8*z + y*(-108.3834525034224_r8 + 153.8390924339484_r8*z))) + &
            y*(-687.913805923122_r8 + z*(748.126026697488_r8 + z*(-379.883572632876_r8 + 140.9317606630898_r8*z)) + &
            y*(674.819060538734_r8 + z*(-1069.887337245828_r8 + (530.4484299696_r8 - 158.40030944233638_r8*z)*z) + &
            y*(-409.779283929806_r8 + y*(149.452282277512_r8 - 218.92375140095282_r8*z) + &
            (681.370187043564_r8 - 133.5392811916956_r8*z)*z))))

       gsw_gibbs = (g03 + g08)*1e-16_r8 

    else

       gsw_gibbs = gsw_error_code(1,func_name)

    end if

    return
  end function gsw_gibbs

  !--------------------------------------------------------------------------
  !==========================================================================
  elemental function gsw_gibbs_pt0_pt0 (sa, pt0)
    !==========================================================================
    !
    ! gibbs_tt at (sa,pt,0)
    !
    ! sa     : Absolute Salinity                            [g/kg]
    ! pt0    : potential temperature                        [deg C]
    ! 
    ! gsw_gibbs_pt0_pt0 : gibbs_tt at (sa,pt,0)         
    !--------------------------------------------------------------------------

    use gsw_mod_teos10_constants, only : gsw_sfac

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in) :: sa, pt0

    real (r8) :: gsw_gibbs_pt0_pt0

    real (r8) :: x2, x, y, g03, g08

    x2 = gsw_sfac*sa
    x = sqrt(x2)
    y = pt0*0.025_r8

    g03 = -24715.571866078_r8 + &
         y*(4420.4472249096725_r8 + &
         y*(-1778.231237203896_r8 + &
         y*(1160.5182516851419_r8 + &
         y*(-569.531539542516_r8 + y*128.13429152494615_r8))))

    g08 = x2*(1760.062705994408_r8 + x*(-86.1329351956084_r8 + &
         x*(-137.1145018408982_r8 + y*(296.20061691375236_r8 + &
         y*(-205.67709290374563_r8 + 49.9394019139016_r8*y))) + &
         y*(-60.136422517125_r8 + y*10.50720794170734_r8)) + &
         y*(-1351.605895580406_r8 + y*(1097.1125373015109_r8 + &
         y*(-433.20648175062206_r8 + 63.905091254154904_r8*y))))

    gsw_gibbs_pt0_pt0 = (g03 + g08)*0.000625_r8

    return
  end function gsw_gibbs_pt0_pt0

  !--------------------------------------------------------------------------
  !==========================================================================
  elemental function gsw_pt_from_ct (sa, ct) 
    !==========================================================================
    !
    ! potential temperature of seawater from conservative temperature
    !
    ! sa     : Absolute Salinity                               [g/kg]
    ! ct     : Conservative Temperature                        [deg C]
    ! p      : sea pressure                                    [dbar]
    !
    ! gsw_pt_from_ct : potential temperature with              [deg C]
    !                  reference pressure of  0 dbar
    !--------------------------------------------------------------------------

    use gsw_mod_toolbox, only : gsw_ct_from_pt, gsw_gibbs_pt0_pt0

    use gsw_mod_teos10_constants, only : gsw_cp0, gsw_ups, gsw_t0

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in) :: sa, ct 

    real (r8) :: gsw_pt_from_ct

    real (r8) :: a5ct, b3ct, ct_factor, pt_num, pt_recden, ct_diff
    real (r8) :: pt, pt_old, ptm, dpt_dct, s1

    real (r8), parameter :: a0 = -1.446013646344788e-2_r8
    real (r8), parameter :: a1 = -3.305308995852924e-3_r8
    real (r8), parameter :: a2 =  1.062415929128982e-4_r8
    real (r8), parameter :: a3 =  9.477566673794488e-1_r8
    real (r8), parameter :: a4 =  2.166591947736613e-3_r8
    real (r8), parameter :: a5 =  3.828842955039902e-3_r8

    real (r8), parameter :: b0 =  1.0_r8
    real (r8), parameter :: b1 =  6.506097115635800e-4_r8
    real (r8), parameter :: b2 =  3.830289486850898e-3_r8
    real (r8), parameter :: b3 =  1.247811760368034e-6_r8

    s1 = sa/gsw_ups

    a5ct = a5*ct
    b3ct = b3*ct

    ct_factor = (a3 + a4*s1 + a5ct)
    pt_num = a0 + s1*(a1 + a2*s1) + ct*ct_factor
    pt_recden = 1.0_r8/(b0 + b1*s1 + ct*(b2 + b3ct))
    pt = pt_num*pt_recden

    dpt_dct = (ct_factor + a5ct - (b2 + b3ct + b3ct)*pt)*pt_recden

    ! Start the 1.5 iterations through the modified Newton-Rapshon iterative,
    ! method, which is also known as the Newton-McDougall method. 

    ct_diff = gsw_ct_from_pt(sa,pt) - ct
    pt_old = pt
    pt = pt_old - ct_diff*dpt_dct
    ptm = 0.5_r8*(pt + pt_old)

    dpt_dct = -gsw_cp0/((ptm + gsw_t0)*gsw_gibbs_pt0_pt0(sa,ptm))

    pt = pt_old - ct_diff*dpt_dct
    ct_diff = gsw_ct_from_pt(sa,pt) - ct
    pt_old = pt
    gsw_pt_from_ct = pt_old - ct_diff*dpt_dct

    return 
  end function gsw_pt_from_ct

  !--------------------------------------------------------------------------
  !==========================================================================
  elemental function gsw_pt_from_t (sa, t, p, p_ref) 
    !==========================================================================
    !   
    ! Calculates potential temperature of seawater from in-situ temperature 
    !
    ! sa     : Absolute Salinity                               [g/kg]
    ! t      : in-situ temperature                             [deg C]
    ! p      : sea pressure                                    [dbar]
    ! p_ref  : reference sea pressure                          [dbar]
    !
    ! gsw_pt_from_t : potential temperature                    [deg C]
    !--------------------------------------------------------------------------

    use gsw_mod_toolbox, only : gsw_entropy_part, gsw_gibbs

    use gsw_mod_teos10_constants, only : gsw_cp0, gsw_sso, gsw_t0, gsw_ups

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in) :: sa, t, p, p_ref 

    real (r8) :: gsw_pt_from_t

    integer no_iter
    real (r8) :: s1, pt, pt_old, dentropy, dentropy_dt
    real (r8) :: true_entropy_part, ptm

    integer, parameter :: n0=0, n2=2

    s1 = sa/gsw_ups

    pt = t + (p-p_ref)*( 8.65483913395442e-6_r8 - &
         s1 *  1.41636299744881e-6_r8 - &
         (p+p_ref)*  7.38286467135737e-9_r8 + &
         t  *(-8.38241357039698e-6_r8 + &
         s1 *  2.83933368585534e-8_r8 + &
         t  *  1.77803965218656e-8_r8 + &
         (p+p_ref)*  1.71155619208233e-10_r8))

    dentropy_dt = gsw_cp0/((gsw_t0 + pt)*(1.0_r8 - 0.05_r8*(1.0_r8 - sa/gsw_sso)))

    true_entropy_part = gsw_entropy_part(sa,t,p)

    do no_iter = 1, 2
       pt_old = pt
       dentropy = gsw_entropy_part(sa,pt_old,p_ref) - true_entropy_part
       pt = pt_old - dentropy/dentropy_dt 
       ptm = 0.5_r8*(pt + pt_old)
       dentropy_dt = -gsw_gibbs(n0,n2,n0,sa,ptm,p_ref)
       pt = pt_old - dentropy/dentropy_dt
    end do

    gsw_pt_from_t = pt

    return
  end function gsw_pt_from_t

  !--------------------------------------------------------------------------
  !==========================================================================
  elemental function gsw_saar (p, long, lat)
    !==========================================================================
    !
    ! Calculates the Absolute Salinity Anomaly Ratio, SAAR at a geographic point.
    !
    ! p      : sea pressure                                    [dbar]
    ! long   : longitude                                       [deg E]     
    ! lat    : latitude                                        [deg N]
    !
    ! gsw_saar : Absolute Salinity Anomaly Ratio               [unitless]
    !--------------------------------------------------------------------------

    use gsw_mod_toolbox, only : gsw_add_barrier, gsw_add_mean, gsw_util_indx

    use gsw_mod_error_functions, only : gsw_error_code

    use gsw_mod_saar_data

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in) :: p, long, lat

    real (r8) :: gsw_saar

    integer :: indx0, indy0, indz0, k, ndepth_max

    real (r8), dimension(4) :: saar, saar_old
    real (r8) :: p0_original, sa_upper, sa_lower, dlong, dlat
    real (r8) :: r1, s1, t1, p_tmp, long360

    character (*), parameter :: func_name = "gsw_saar"

    long360 = long
    if (long360.lt.0.0_r8) long360 = long360 + 360.0_r8

    indx0 = floor(1.0_r8 + (nx-1)*(long360-longs_ref(1)) / &
         (longs_ref(nx)-longs_ref(1)))

    indy0 = floor(1.0_r8 + (ny-1)*(lat-lats_ref(1)) / (lats_ref(ny)-lats_ref(1)))

    if ((indx0.ge.1 .and. indx0.le.nx) .and. (indy0.ge.1 .and. indy0.le.ny)) then
       if (indx0.eq.nx) indx0 = nx-1
       if (indy0.eq.ny) indy0 = ny-1
    else
       ! This is to catch any out-of-range or nonsense lat/long input (including
       ! NaN, +Inf, -Inf etc). Note: NaNs will not satisfy any "if" conditional
       ! so will be trapped by the "else".
       gsw_saar = gsw_error_code(2,func_name)
       return
    end if

    ! Look for the maximum valid "ndepth_ref" value around our point.
    ! Note: invalid "ndepth_ref" values are NaNs (a hangover from the codes
    ! Matlab origins), but we have replaced the NaNs with a value of 999,
    ! hence we need an additional upper-limit check in the code below so they
    ! will not be recognised as valid values.
    ndepth_max = -1
    do k = 1,4
       if ((ndepth_ref(indy0+delj(k),indx0+deli(k)).gt.0) .and. &
            (ndepth_ref(indy0+delj(k),indx0+deli(k)).lt.99)) &
            ndepth_max = max(ndepth_max,ndepth_ref(indy0+delj(k),indx0+deli(k)))
    end do

    ! If we are a long way from the ocean then there will be no valid "ndepth_ref"
    ! values near the point (ie. surrounded by NaNs) - so just return SAAR = 0.0
    if (ndepth_max.eq.-1) then
       gsw_saar = 0.0_r8 
       return
    end if

    p0_original = p
    p_tmp = p
    if (p_tmp.gt.p_ref(ndepth_max)) p_tmp = p_ref(ndepth_max)
    indz0 = gsw_util_indx(p_ref,p_tmp)

    dlong = longs_ref(indx0+1) - longs_ref(indx0)
    dlat = lats_ref(indy0+1) - lats_ref(indy0)

    r1 = (long360-longs_ref(indx0)) / dlong
    s1 = (lat-lats_ref(indy0)) / dlat
    t1 = (p_tmp-p_ref(indz0))/(p_ref(indz0+1)-p_ref(indz0))

    do k = 1,4
       saar(k) = saar_ref(indz0,indy0+delj(k),indx0+deli(k))
    end do

    if (  longs_pan(1).le.long360 .and. long360.le.longs_pan(npan)-0.001_r8 .and. &
         lats_pan(npan).le.lat     .and.     lat.le.lats_pan(1)) then
       saar_old = saar
       call gsw_add_barrier(saar_old,long360,lat,longs_ref(indx0), &
            lats_ref(indy0),dlong,dlat,saar)
    else if (abs(sum(saar)).ge.1e10_r8) then
       saar_old = saar
       call gsw_add_mean(saar_old,saar)
    end if

    sa_upper = (1.0_r8-s1)*(saar(1) + r1*(saar(2)-saar(1))) + s1*(saar(4) + &
         r1*(saar(3)-saar(4)))

    do k = 1,4
       saar(k) = saar_ref(indz0+1,indy0+delj(k),indx0+deli(k))
    end do

    if (  longs_pan(1).le.long360 .and. long360.le.longs_pan(npan)-0.001_r8 .and. &
         lats_pan(npan).le.lat     .and.     lat.le.lats_pan(1)) then
       saar_old = saar
       call gsw_add_barrier(saar_old,long360,lat,longs_ref(indx0), &
            lats_ref(indy0),dlong,dlat,saar)
    else if (abs(sum(saar)).ge.1e10_r8) then 
       saar_old = saar
       call gsw_add_mean(saar_old,saar)
    end if

    sa_lower = (1.0_r8-s1)*(saar(1) + r1*(saar(2)-saar(1))) + s1*(saar(4) + &
         r1*(saar(3)-saar(4)))
    if (abs(sa_lower).ge.1e10_r8) sa_lower = sa_upper
    gsw_saar = sa_upper + t1*(sa_lower-sa_upper)

    if (abs(gsw_saar).ge.1e10_r8) gsw_saar = gsw_error_code(3,func_name)

    return
  end function gsw_saar

  !--------------------------------------------------------------------------
  !==========================================================================
  elemental function gsw_sa_from_sp_baltic (sp, long, lat)
    !==========================================================================
    !
    ! For the Baltic Sea, calculates Absolute Salinity with a value
    ! computed analytically from Practical Salinity
    !
    ! sp     : Practical Salinity                              [unitless]
    ! long   : longitude                                       [deg E]     
    ! lat    : latitude                                        [deg N]
    !
    ! gsw_sa_from_sp_baltic : Absolute Salinity                [g/kg] 
    !--------------------------------------------------------------------------

    use gsw_mod_toolbox, only : gsw_util_xinterp1

    use gsw_mod_baltic_data

    use gsw_mod_teos10_constants, only : gsw_sso

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in) :: sp, long, lat

    real (r8) :: gsw_sa_from_sp_baltic

    real (r8) :: xx_left, xx_right

    if (xb_left(2).lt.long .and. long.lt.xb_right(1) .and. &
         yb_left(1).lt.lat  .and.  lat.lt.yb_left(3)) then

       xx_left = gsw_util_xinterp1(yb_left, xb_left, lat)

       xx_right = gsw_util_xinterp1(yb_right, xb_right, lat)

       if(xx_left.le.long .and. long.le.xx_right) then
          gsw_sa_from_sp_baltic = ((gsw_sso - 0.087_r8)/35.0_r8)*sp + 0.087_r8
       else
          gsw_sa_from_sp_baltic = 9e15_r8
       end if

    else
       gsw_sa_from_sp_baltic = 9e15_r8
    end if

    return
  end function gsw_sa_from_sp_baltic

  !--------------------------------------------------------------------------
  !==========================================================================
  elemental function gsw_sa_from_sp (sp, p, long, lat)       
    !==========================================================================
    !
    ! Calculates Absolute Salinity, SA, from Practical Salinity, SP
    !
    ! sp     : Practical Salinity                              [unitless]
    ! p      : sea pressure                                    [dbar]
    ! long   : longitude                                       [DEG E]     
    ! lat    : latitude                                        [DEG N]
    !
    ! gsw_sa_from_sp   : Absolute Salinity                     [g/kg]
    !--------------------------------------------------------------------------

    use gsw_mod_toolbox, only : gsw_saar, gsw_sa_from_sp_baltic

    use gsw_mod_error_functions, only : gsw_error_code, gsw_error_limit

    use gsw_mod_teos10_constants, only : gsw_ups

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in) :: sp, p, long, lat       

    real (r8) :: gsw_sa_from_sp

    real (r8) :: saar, sa_baltic

    character (*), parameter :: func_name = "gsw_sa_from_sp"

    sa_baltic = gsw_sa_from_sp_baltic(sp,long,lat)

    if (sa_baltic .lt. 1e10_r8) then

       gsw_sa_from_sp = sa_baltic

    else

       saar = gsw_saar(p,long,lat)
       if (saar .gt. gsw_error_limit) then
          gsw_sa_from_sp = gsw_error_code(1,func_name,saar)
       else
          gsw_sa_from_sp = gsw_ups*sp*(1.0_r8 + saar)
       end if

    end if

    return
  end function gsw_sa_from_sp

  !--------------------------------------------------------------------------
  !==========================================================================
  elemental function gsw_t_from_ct (sa, ct, p)  
    !==========================================================================
    !
    ! Calculates in-situ temperature from Conservative Temperature of seawater  
    !
    ! sa      : Absolute Salinity                              [g/kg]
    ! ct      : Conservative Temperature                       [deg C]
    !
    ! gsw_t_from_ct : in-situ temperature                      [deg C]
    !--------------------------------------------------------------------------

    use gsw_mod_toolbox, only : gsw_pt_from_ct, gsw_pt_from_t

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in) :: sa, ct, p  

    real (r8) :: gsw_t_from_ct

    real (r8) :: pt0

    real (r8), parameter :: p0 = 0.0_r8

    pt0 = gsw_pt_from_ct(sa,ct)
    gsw_t_from_ct = gsw_pt_from_t(sa,pt0,p0,p)

    return
  end function gsw_t_from_ct

  !--------------------------------------------------------------------------
  !==========================================================================
  pure function gsw_util_indx (x, z, kstart) result(ki)
    !==========================================================================
    !
    !  Finds the index of the value in a monotonically increasing array
    !
    !  x      :  array of monotonically increasing values
    !  z      :  value to be indexed
    !  kstart :  (optional) restrict search to x(kstart:)
    !
    !  ki     : index k : if x(k) <= z < x(k+1), or
    !               n-1 : if z = x(n)
    !--------------------------------------------------------------------------

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in) :: x(:), z
    integer, intent(in), optional :: kstart

    integer :: ki

    integer :: ku, kl, km, n

    n = size(x)

    if ((z .gt. x(1)) .and. (z .lt. x(n))) then

       if (present(kstart)) then
          kl = kstart
       else
          kl = 1
       end if

       ku = n
       do while (ku-kl .gt. 1)
          km = (ku + kl) / 2
          if (z .gt. x(km)) then
             kl = km
          else
             ku = km
          endif
       end do
       ki = kl
       if (z .eq. x(ki+1)) ki = ki + 1

    elseif (z .le. x(1)) then

       ki = 1

    else    !if (z.ge.x(n)) then - removed (GBH 3/6/2015) so z=NaN has somewhere to go (otherwise ki is undefined and gives segmentation fault)

       ki = n-1

    end if

    return
  end function gsw_util_indx

  !--------------------------------------------------------------------------

  !==========================================================================
  pure function gsw_util_xinterp1 (x, y, x0)
    !==========================================================================
    !
    ! Linearly interpolate a real monotonic array.
    !
    ! x      : x array (must be monotonically increasing)
    ! y      : y array
    ! x0     : x value to be interpolated
    !
    ! xinterp1 : linearly interpolated y value
    !--------------------------------------------------------------------------

    use gsw_mod_toolbox, only : gsw_util_indx

    use gsw_mod_kinds

    implicit none

    real (r8), intent(in) :: x0
    real (r8), intent(in) :: x(:), y(:)

    real (r8) :: gsw_util_xinterp1

    integer :: k
    real (r8) :: r

    k = gsw_util_indx(x,x0)
    r = (x0-x(k))/(x(k+1)-x(k))
    gsw_util_xinterp1 = y(k) + r*(y(k+1)-y(k))

    return
  end function gsw_util_xinterp1

  !--------------------------------------------------------------------------

end module gsw_mod_toolbox
